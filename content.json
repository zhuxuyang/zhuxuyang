[{"title":"个人电脑使用docker客户端部署单机k8s","date":"2020-07-26T03:10:42.000Z","path":"个人电脑使用docker客户端部署单机k8s/","text":"docker 客户端安装k8sdocker 客户端自带的k8s 工具一直在starting这是因为对应的包下不下来。首先自己查看一下自己k8s的版本。Kubernetes v1.18.8 用的docker镜像是下面这些，手动下载就行 如果是其他版本k8s，这个仓库有处理方案：https://github.com/AliyunContainerService/k8s-for-docker-desktop 1234567891011121314151617181920212223242526272829docker pull naison/kube-proxy:v1.18.8docker pull naison/kube-apiserver:v1.18.8docker pull naison/kube-controller-manager:v1.18.8docker pull naison/kube-scheduler:v1.18.8docker pull naison/weave-npc:2.7.0docker pull naison/weave-kube:2.7.0docker pull naison/pause:3.2docker pull naison/coredns:1.6.7docker pull naison/etcd:3.4.3-0 docker tag docker.io/naison/kube-proxy:v1.18.8 k8s.gcr.io/kube-proxy:v1.18.8docker tag docker.io/naison/kube-apiserver:v1.18.8 k8s.gcr.io/kube-apiserver:v1.18.8docker tag docker.io/naison/kube-controller-manager:v1.18.8 k8s.gcr.io/kube-controller-manager:v1.18.8docker tag docker.io/naison/kube-scheduler:v1.18.8 k8s.gcr.io/kube-scheduler:v1.18.8docker tag docker.io/naison/weave-npc:2.7.0 docker.io/weaveworks/weave-npc:2.7.0docker tag docker.io/naison/weave-kube:2.7.0 docker.io/weaveworks/weave-kube:2.7.0docker tag docker.io/naison/pause:3.2 k8s.gcr.io/pause:3.2docker tag docker.io/naison/coredns:1.6.7 k8s.gcr.io/coredns:1.6.7docker tag docker.io/naison/etcd:3.4.3-0 k8s.gcr.io/etcd:3.4.3-0 docker image rm docker.io/naison/kube-proxy:v1.18.8docker image rm docker.io/naison/kube-apiserver:v1.18.8docker image rm docker.io/naison/kube-controller-manager:v1.18.8docker image rm docker.io/naison/kube-scheduler:v1.18.8docker image rm docker.io/naison/weave-npc:2.7.0docker image rm docker.io/naison/weave-kube:2.7.0docker image rm docker.io/naison/pause:3.2docker image rm docker.io/naison/coredns:1.6.7docker image rm docker.io/naison/etcd:3.4.3-0 然后安装k8s的dashboardhttps://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/ https://www.qikqiak.com/k8s-book/docs/17.%E5%AE%89%E8%A3%85%20Dashboard%20%E6%8F%92%E4%BB%B6.html","tags":[{"name":"docker","slug":"docker","permalink":"https://itwork.group/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://itwork.group/tags/k8s/"}]},{"title":"新冠肺炎诗三则","date":"2020-02-25T15:11:34.000Z","path":"新冠肺炎诗三则/","text":"一寒风瑟瑟树影重，万里城关路不通。 千家万户布遮面，人间疾苦正月中。 二疾风长入夜，初雪庚子年 灾祸四处起，黎民水火中 作坊多倒闭，大厂少发钱 今人不学史，有话也难言 三年纪轻轻哪里愁 人心惶惶疫未休 若不工作吃谁饭 贫穷使我去杭州","tags":[]},{"title":"失眠有感","date":"2020-02-25T15:04:37.000Z","path":"失眠有感/","text":"晚上失眠到两三点，突然诗兴大发 应有静谧月光， 应有暗香扣窗， 姑娘悄悄进我心房， 温柔的床， 依旧难入梦乡。","tags":[]},{"title":"","date":"2020-01-11T02:05:48.629Z","path":"命令/","text":"123456root@unbuntu:/# cat &lt;&lt; EOF &gt;abcd.txt&gt; uu&gt; hello world&gt; ii&gt; hah&gt; EOF","tags":[]},{"title":"golang重点笔记","date":"2019-09-23T06:52:35.000Z","path":"golang重点笔记/","text":"go语言的闭包重点 闭包不是某一种语言特有的机制,但常出现在函数式编程中,尤其是函数占据重要地位的编程语言. 闭包的直观表现是函数内部嵌套了函数,并且内部函数访问了外部变量,从而使得自由变量获得延长寿命的能力. 闭包中使用的自由变量一般有值传递和引用传递两种形式,示例中的斐波那契数列生成器利用的是引用而循环变量示例用的是值传递. Go不支持函数嵌套但支持匿名函数,语法层面的差异性掩盖不了闭包整体的统一性. 速记：只要函数还被引用着，里面的变量不会被销毁 示例: 斐波那契 12345678910111213141516func fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; a, b = b, a+b return a &#125;&#125;// 1 1 2 3 5 8 13 21 34 55func TestFibonacci(t *testing.T) &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Print(f(), \" \") &#125; fmt.Println()&#125; 示例：引用传递和值传递 12345678910111213141516171819202122232425262728293031323334 func countByClosureWithOk() []func() int &#123; var arr []func() int for i := 1; i &lt;= 3; i++ &#123; func(n int) &#123; arr = append(arr, func() int &#123; return n &#125;) &#125;(i) &#125; return arr&#125;func countByClosureButWrong() []func() int &#123; var arr []func() int for i := 1; i &lt;= 3; i++ &#123; arr = append(arr, func() int &#123; return i &#125;) &#125; return arr&#125;func TestCountByClosure(t *testing.T) &#123; // 1 2 3 for _, c := range countByClosureWithOk() &#123; t.Log(c()) &#125; // 4 4 4 for _, c := range countByClosureButWrong() &#123; t.Log(c()) &#125;&#125; 上面的例子，在使用闭包的时候，都把函数存到了一个变量里，这样整个函数包括里面的变量，都不会被释放，直到不再引用这个变量。这个跟语言的垃圾回收机制有关。","tags":[{"name":"golang","slug":"golang","permalink":"https://itwork.group/tags/golang/"}]},{"title":"vagrant搭建k8s集群","date":"2019-09-07T13:55:55.000Z","path":"vagrant搭建k8s集群/","text":"我使用之前的vagrant工具，启动了ubuntu16.04虚拟机，并且安装了docker,git工具，然后导出了自己的vagrant box文件，命名为docker.box。 然后基于这个box 搭建k8s。 宿主机的配置在合适的地方创建cluster文件夹，然后将docker.box移入这个目录，不移入也没关系，我这是便于管理。然后参考之前的教程，步骤都是一样滴，添加box到vagrant，执行vagrant init docker，在当前目录生成Vagrantfile，然后修改默认的Vagrantfile，启动虚拟机。 Vagrantfile配置文件改为： 12345678910Vagrant.configure(\"2\") do |config| config.vm.box = \"docker\" config.vm.define \"master\" do |master| # 第一个虚拟机,名字为master，配置命名为master master.vm.network \"private_network\", ip: \"192.168.100.100\" master.vm.hostname = \"master\" master.vm.provider \"virtualbox\" do|pmaster| pmaster.memory = \"1024\" pmaster.cpus = 1 end end k8s安装基础环境配置1234567891011121314151617181920212223242526272829303132333435363738# 创建安装源配置文件sudo touch /etc/apt/sources.list.d/kubernetes.list# 设置文件可写sudo chmod 666 /etc/apt/sources.list.d/kubernetes.list# 添加下载源到文件末尾sudo cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF# 更新源sudo apt update# 然而报错了，说 the public key is not available: NO_PUBKEY 6A030B21BA07F4FB# 添加key的后八位 BA07F4FB 到系统中，这个步骤其实是k8s的安全下载措施# 在机器上生成证书sudo gpg --keyserver keyserver.ubuntu.com --recv-keys BA07F4FB# 添加证书到k8s的环境中sudo gpg --export --armor BA07F4FB | sudo apt-key add -# 更新下载源sudo apt update# 一般涉及到网络的服务，都会禁止系统自带的安全模块，防止出错# 禁止系统自带的防火墙unix firewall sudo ufw disable# 关闭系统swap,一般是永久关闭，然而vagrant的ubuntu16.04虚拟机默认就是关闭的# 在系统文件 /etc/fstab 里没有swap.img的配置，如果有，注释掉就是永久关闭swap了# 禁止selinux,这是ubuntu自带的类似360的软件,这个我猜不做也可以，# 不过这个软件影响机器性能，还没什么用，禁了。要禁止它需要下载他的工具selinux-utilssudo apt install -y selinux-utils# 关闭它setenforce 0# 查看是否已经关闭 selinuxsudo getenforce # 重启机器sudo shutdown -r now k8s系统网络环境配置创建 /etc/sysctl.d/k8s.conf 文件，写入内容： 12345678# 修改文件可读可写sudo chmod 666 /etc/sysctl.d/k8s.conf# 添加内容sudo cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.ipv4.ip_forward = 1net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF 与视频不一致，我这个是官网复制的，视频里多了一行 vm.swappiness=0 1234567# 使用modproble加载网桥透明防火墙sudo modprobe br_netfilter# 使配置文件生效sudo sysctl -p /etc/sysctl.d/k8s.conf# 安装k8ssudo apt updatesudo apt-get install kubelet kubernetes-cni kubectl kubeadm vagrant 里如果需要root权限，可能无法授权。可以先sudo passwd root 先给root设定一个密码就可以了。 重启机器，到这个时候，如果执行kubectl get nodes,显示 1The connection to the server localhost:8080 was refused - did you specify the right host or port? 这是网络环境还不对，但是命令已经有了。 使用vagrant给机器做个镜像，导出镜像为 k8s.box ，添加k8s.box到 vagrant box list 里，之后需要根据这个box 部署集群。 集群的机器准备准备三台虚拟机，分别为master,slave01,slave02 在cluster目录下，创建两个文件夹 master和slave，分别在这两个文件夹下创建Vagrantfile 第一个： 1234567891011Vagrant.configure(\"2\") do |config| config.vm.box = \"k8s\" config.vm.define \"master\" do |master| # 第一个虚拟机，打算作为k8s的master,配置命名为master master.vm.network \"private_network\", ip: \"192.168.100.100\" master.vm.hostname = \"master\" master.vm.provider \"virtualbox\" do|pmaster| pmaster.memory = \"1024\" pmaster.cpus = 1 end endend 第二个 123456789101112131415161718192021Vagrant.configure(\"2\") do |config| # 表示使用版本2的配置文件格式启动，配置命名为config，下面可以引用 config.vm.box = \"k8s\" # 指定box list 里的 box config.vm.define \"slave01\" do |slave01| # 虚拟机名字为slave01，配置命名为slave01 master.vm.network \"private_network\", ip: \"192.168.100.101\" master.vm.hostname = \"slave01\" master.vm.provider \"virtualbox\" do|pslave01| pmaster.memory = \"1024\" pmaster.cpus = 1 end end config.vm.define \"slave02\" do|slave02| slave01.vm.hostname = \"slave02\" slave01.vm.network \"private_network\", ip: \"192.168.100.102\" slave01.vm.provider \"virtualbox\" do|pslave02| pslave01.memory = \"1024\" pslave01.cpus = 1 end end end 启动三个虚拟机，根据各自的ip修改他们的 /etc/hosts,在文件中添加 123192.168.100.100 master192.168.100.101 slave01192.168.100.102 slave02 使它们可以根据机器名字互相ping通 集群配置文件登陆master,在～目录下创建working文件夹，然后生成配置文件 123mkdir workingcd workingkubeadm config print init-defaults ClusterConfiguration &gt; kubeadm.conf 配置文件稍作修改 123456789# 镜像源修改imageRepository: registry.aliyuncs.com/google_containers # 本机ipadvertiseAddress: 192.168.100.100# 最后的网络networking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 # pod之间的通信网络 serviceSubnet: 10.96.0.0/12 # pod之间的通信网络 12345678# 查看需要下载的模块kubeadm config images list --config kubeadm.conf# 下载模块kubeadm config images pull --config kubeadm.conf# 初始化生成mastersudo kubeadm init --config ./kubeadm.conf 说明： registry.aliyuncs.com/google_containers/kube-apiserver:v1.16.0 apiserver提供对外接口，外部通过访问apiserver进入到集群中，所以每个kubelet都有这个 registry.aliyuncs.com/google_containers/kube-controller-manager:v1.16.0 Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。 registry.aliyuncs.com/google_containers/kube-scheduler:v1.16.0。调度器是一个策略丰富、拓扑感知、工作负载特定的功能，显著影响可用性、性能和容量。调度器需要考虑个人和集体 的资源要求、服务质量要求、硬件/软件/政策约束、亲和力和反亲和力规范、数据局部性、负载间干扰、完成期限等。 工作负载特定的要求必要时将通过 API 暴露。 registry.aliyuncs.com/google_containers/kube-proxy:v1.16.0. 主要做内部的负载均衡 registry.aliyuncs.com/google_containers/pause:3.1。Kubernetes创建Pod时，首先会创建一个pause容器，为Pod指派一个唯一的IP地址。然后，以pause的网络命名空间为基础，创建同一个Pod内的其它容器（–net=container:xxx）。因此，同一个Pod内的所有容器就会共享同一个网络命名空间，在同一个Pod之间的容器可以直接使用localhost进行通信。 registry.aliyuncs.com/google_containers/etcd:3.3.15-0 各个容器数据的内部一致性 registry.aliyuncs.com/google_containers/coredns:1.6.2 上面的模块安装后，会提示执行如下指令 12345678## 本地环境配置mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 其他机器加入集群，这个提示的token要备份，以后其他机器加入集群都要用# kubeadm join 192.168.100.100:6443 --token 巴啦啦啦一大堆 12345# 开机启动sudo systemctl enable kubeletsudo systemctl start kubelet# 查看命令,这个时候终于有了,但是status还是NotReady，是因为还没有配置内部网络环境kubectl get node 配置集群的内部网络环境flannel123456789101112# 下载一个配置文件wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml# 修改里面的 net-conf.json选项，网络为 kubeadm.conf配置文件里面的网络# &#123;# \"Network\": \"10.244.0.0/16\",# \"Backend\": &#123;# \"Type\": \"vxlan\"# &#125;# &#125;# 执行命令生效flannel配置kubeadm apply -f kube-flannel.yml 过一会儿，等配置生效。然后执行 kubectl get nodes 命令，status就是ready了。到此，master终于弄好了。 添加其他机器到集群中将master机器里的两个文件分别复制到slave01和slave02机器里。 /etc/kubernetes/admin.conf ~/working/kube-flannel.yml 登陆进入slave01机器，执行 12345678910# 开机启动sudo systemctl enable kubeletsudo systemctl start kubelet# 用admin.conf文件生成k8s配置文件mkdir -p $HOME/.kubesudo cp -i admin.conf .kube/config sudo chown $(id -u):$(id -g) .kube/config # 用mster初始化的时候生成的信息加入到集群中sudo kubeadm join 192.168.100.100:6443 --token abcde巴拉巴拉一大堆 到此为止，slave01已经加入到集群里，过一会儿等它生效，执行 kubectl get nodes 命令，会看到有两台机器，且status是ready了。slave02也是一样的操作。 最后，如果slave机器一直都是notready，还需要配置slave01和slave02可以互相通信，就需要用到master里复制过来的kube-flannel.yml文件了 1kubectl apply -f kube-flannel.yml 总结几个大步骤 master机器上kubeadm init –config 创建master，生成配置文件 配置集群的内部通信网络，flannel网络 配置node节点，分配网络 让node加入集群 最后到此为止，终于部署好三台机器的k8s集群，可以分别给master和node做镜像，防止以后还要重新这样部署一遍，啦啦啦 ：）","tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://itwork.group/tags/vagrant/"},{"name":"docker","slug":"docker","permalink":"https://itwork.group/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://itwork.group/tags/k8s/"}]},{"title":"mac自带的工具sips处理图片翻转剪切格式转换","date":"2019-08-15T10:02:33.000Z","path":"mac自带的工具sips处理图片翻转剪切格式转换/","text":"mac上自带一个工具，有时候仅仅是简单的修改一下图片，就不需要额外下载其他工具，很有用。叫做sips，是一个命令行工具，简单的处理图片或者批量处理图片的神器。 记住，不指定输出文件会覆盖原文件，一定要先备份 12345678910111213141516171819202122232425262728293031#裁剪 其中600表示高度为600px,宽度为按比例缩放sips -Z 600 aa.jpg#格式转换, 使用 -s 参数可以修改图片格式为指定值，#sips 支持 jpeg | tiff | png | gif | jp2 | pict | #bmp | qtif | psd | sgi | tga 共 11 种格式。sips -s format jpeg --out a.jpg aa.png# 指定宽高输出图片sips --out output.png -z $&#123;height&#125; $&#123;width&#125; input.png# 制定宽度、保持比例输出图片sips --out output.png --resampleWidth $&#123;width&#125; input.png# 指定宽度、保持比例(会覆盖源图片)sips --resampleWidth $&#123;width&#125; *.jpg# 指定宽高(会覆盖源图片)sips -z $&#123;height&#125; $&#123;width&#125; *.jpg# 顺时针旋转 90 度sips -r 90 image_file_name# 水平翻转图片 # horizontal/vertical 水平／垂直sips -f horizontal image_file_name# 获取图片 meta 信息sips -g pixelWidth -g pixelHeight image_file_name# 可使用查看更多信息man sips","tags":[{"name":"sips","slug":"sips","permalink":"https://itwork.group/tags/sips/"}]},{"title":"ubuntu双显卡自动安装nvidia显卡驱动","date":"2019-01-19T02:20:40.000Z","path":"ubuntu双显卡自动安装nvidia显卡驱动/","text":"最近在玩深度学习，正好手上有一台Nvidia显卡的游戏本。于是装个ubuntu18.04玩玩。装官方驱动遇到了双显卡导致的显卡驱动的各种问题。后来一顿操作，发现其实可以几行代码搞定，不需要像网上流传的那么繁琐。。 装好系统后，首先要进去桌面，这里网上有常见的办法，开机设置 nomodeset 就好 进入桌面后，联网，换源。 首先，检测你的NVIDIA显卡型号和推荐的驱动程序的模型，并显示计算机即将安装的驱动。 1ubuntu-drivers devices 如果同意计算机的以上推荐设置，执行 1sudo ubuntu-drivers autoinstall 接下来就是等待，装好后重启。","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://itwork.group/tags/ubuntu/"},{"name":"nvidia","slug":"nvidia","permalink":"https://itwork.group/tags/nvidia/"},{"name":"双显卡","slug":"双显卡","permalink":"https://itwork.group/tags/双显卡/"}]},{"title":"golang的依赖管理gomod的使用","date":"2019-01-09T05:20:26.000Z","path":"golang的依赖管理gomod的使用/","text":"以前的go语言项目，代码依赖是个麻烦的事情。所有的项目必须放在GOPATH的src目录下，如果不同项目依赖同一个库的不同版本，就比较麻烦，不好管理。现在go语言终于有了go mod工具，可以像java一样管理依赖，工程代码可以放在其他目录了。 环境变量设置设置环境变量 GO111MODULE ，值为下面三选一。 GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。 GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。 GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形： 当前目录在GOPATH/src之外且该目录包含go.mod文件。 当前文件在包含go.mod文件的目录下面。 既然默认是自动的，那么这个环境变量一般可以不设置。 go mod的使用 在GOPATH 目录之外新建一个目录，并使用go mod init 初始化生成go.mod 文件。只要有了这个文件，那么项目就使用了gomod来管理依赖了。 123mkdir testgomod # 项目名叫testgomodcd testgomodgo mod init testgomod # 初始化go mod ,在当前目录生成go.mod文件 这个时候go.mod内容为,还没有任何依赖 123module testmodgo 1.12 在testgomod下创建main.go 文件，里面有两个常用依赖，内容为： 123456789101112package mainimport ( \"github.com/gin-gonic/gin\" \"github.com/jinzhu/gorm\" \"log\")func main() &#123; log.Print(gorm.Model&#123;&#125;) log.Print(gin.Default())&#125; 这个时候执行go build, gomod 会自动拉取相关依赖包，然后在go.mod里加入依赖信息，go.mod内容为： 12345678module testmodgo 1.12require ( github.com/gin-gonic/gin v1.4.0 github.com/jinzhu/gorm v1.9.10) 依赖包的源码在$GOPATH/pkg/mod目录下。依赖包的版本可以在go.mod里指定版本号，修改后再次执行 go build，就可以更新依赖。以后就再也不需要go get ./…了。 go proxy如果一些依赖无法下载，可以使用go proxy 123export GOPROXY=https://goproxy.io# 或者使用阿里的export GOPROXY=https://mirrors.aliyun.com/goproxy/","tags":[{"name":"golang","slug":"golang","permalink":"https://itwork.group/tags/golang/"}]},{"title":"大多完美者，不过是想象","date":"2018-12-26T06:10:42.000Z","path":" 大多完美者，不过是想象/","text":"​ 很久之前，我在书摊上翻过一本书，内容是古诗词的鉴赏类的。因为当时手机没电，又无分文在身，就没买。但是之后很久我都对这本书耿耿于怀，不能忘记。然而我已经想不起书名了，即使我多次在各大购书网站搜索，也没有找到线索。在这过程中，也发现了不少优秀的书籍，但是总觉得记忆中的那本更胜一筹，若不再次读到那本书，实在难以释怀。至今已有大半年，每每想起，不是滋味。 ​ 今天又想起这件事，照例根据依稀记得的书中内容搜索此书，终于被我找到。发现与其他同类图书相比并无突出之处。不敢相信，反复确认，内容确是当初所见。但是为什么在我的印象里这本书是如此的完美呢，如此让我念念不忘呢？ ​ 原来，大多的完美，不过是想象罢了。不止是读书，生活中其他的事情都是如此。很多人总觉得自己的工作不如意，伴侣不完美，但是真的有这么差么。其实每个人所拥有的，何尝不是别人所羡慕的呢。","tags":[]},{"title":"人生道理记录","date":"2018-12-15T13:43:07.000Z","path":"人生道理记录/","text":"这篇记录生活中看到听到的道理，只记录内容不记录解释。模仿古人竹简刻字，时时回顾。都是至理名言呐。 爱而知其恶，憎而知其善。 —— 出自《中庸》 大多完美者，不过是想象。—— 我自己的生活感悟，文章写在了博客的生活菜单下。","tags":[{"name":"道理","slug":"道理","permalink":"https://itwork.group/tags/道理/"}]},{"title":"nginx配置文件服务器","date":"2018-09-25T05:24:36.000Z","path":"nginx配置文件服务器/","text":"nginx文件服务器，可以像在本地一样浏览查看在配置文件里添加 1234567891011server &#123; listen 8082; server_name *.*.*.*; # 服务器的域名或者ip charset utf-8; # 避免中文乱码 root /home; # 存放文件的目录,如果使用nginx默认的服务器/usr/share之后的目录，会破坏默认的80端口 服务器，所以这里使用home目录 location / &#123; autoindex on; # 索引,是否显示文件夹目录 autoindex_exact_size on; # 显示文件大小，打开关闭是单位为Mb和kb autoindex_localtime on; # 显示文件时间 &#125; &#125; 浏览器访问对应端口就可以看到目录了，可以放一些文件，方便在其他设备上查看","tags":[{"name":"nginx","slug":"nginx","permalink":"https://itwork.group/tags/nginx/"}]},{"title":"docker自动化部署应用","date":"2018-09-24T09:38:40.000Z","path":"docker自动化部署应用/","text":"最简单的是使用第三方的服务，daocloud在daocloud里绑定github，创建项目，绑定github仓库。 代码仓库必须包含Dockerfile，这样每次推送代码到github，就会触发docker build 生成docker镜像。如果需要部署，在应用界面里面的发布选项中选择自动发布就行，这样每次推送代码应用就更新了。这是小型项目最简单的方案了。（有时候频繁发布可能获取不到最新的代码版本，感觉不对的时候可以对比界面上的代码提交版本号）","tags":[{"name":"docker","slug":"docker","permalink":"https://itwork.group/tags/docker/"}]},{"title":"redis的事务的重点","date":"2018-09-06T12:52:31.000Z","path":"redis事务的重点/","text":"每一句单独执行的redis命令都是原子性的，不需要考虑高并发数据被修改的情况，如果必须要依次执行多条，需要使用事务。 使用redis的事务，需要注意几点 分三个步骤，multi开启，然后一系列操作，进入队列，然后exec统一依次执行队列，不会乱顺序。 如果入队之后不想执行了，使用discard取消事务操作。 如果入队的命令输入错误，redis自动会取消事务，并且队列里之前进入的命令也不会执行。 如果入队完成之后，执行了exec，但是有命令执行的时候出错了(常见的是不是数字类型的值却incr自增)，那么仅仅是出错的命令失效，不影响队列里其他的命令的执行。 使用watch的事务 事务里面某个命令在入队阶段报错，那么事务直接返回nil,所有命令不生效，且watch也失效 如果在队列之前使用了watch监视了某个字段key1，那么如果key1在multi之后，exec之前被其他客户端修改过，那么整个事务队列里面的命令都不生效，事务返回nil。且watch也失效 事务成功执行，watch自然也失效 总结使用事务的时候，事务里的命令会组成队列在exec后统一依次执行。生效情况分两种： 入队错误和watch的字段被其他客户端修改，队列里的命令全部不生效 exec后队列里的部分命令执行的时候出错，其他命令也会执行，且数据不发生回滚。所以redis的事务和其他关系型数据库的事务不一样。 一个客户端watch了一些字段后，只要执行了事务，那么不管事务是否成功执行，都会取消掉这个客户端对这些字段的监视，需要重新watch。 大概就这些","tags":[{"name":"redis","slug":"redis","permalink":"https://itwork.group/tags/redis/"}]},{"title":"使用docker部署nginx,并反向代理转发请求","date":"2018-09-03T10:17:23.000Z","path":"使用docker部署nginx-并反向代理转发请求/","text":"docker版nginx123456789101112131415161718192021222324252627282930# 在～目录创建web文件夹,结构为# .# └── web# └── nginx ## 查询相关镜像docker search nginx #获取容器docker pull nginx#跑起来试试docker run -p 80:80 -d nginx#容器改个名字docker rename funny_hypatia nginx#进入～/web/nginx目录，复制配置文件到本地～/web/nginxdocker cp nginx:/etc/nginx/nginx.conf .#复制基础网页文件到本地docker cp nginx:/usr/share/nginx/html ～/web/nginx/www# 现在调整目录结构为# └── web# ├── nginx# │ ├── conf# │ │ ├── my_nginx.conf# │ │ └── nginx.conf# │ └── log# └── www# └── html# ├── 50x.html# └── index.htmldocker run -d -p 80:80 --name nginx -v ~/web/www/html:/usr/share/nginx/html -v ~/web/nginx/conf/my_nginx.conf:/etc/nginx/nginx.conf -v ~/web/nginx/log:/var/log/nginx nginx 反向代理在my_nginx.conf 的http里加上配置，这样配置浏览器访问这台机器，内容显示为百度，测试通过。 12345678server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://itwork.group; &#125;&#125; 注意server监听的端口，在开启nginx容器的时候需要做端口映射到宿主机上","tags":[{"name":"docker","slug":"docker","permalink":"https://itwork.group/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://itwork.group/tags/nginx/"}]},{"title":"ssh连接长时间闲置不断线","date":"2018-09-03T10:14:49.000Z","path":"ssh连接长时间闲置不断线/","text":"ssh 连接上长时间空闲不掉线，省去重新登陆的麻烦事情。在本地创建 ～/.ssh/config 文件，Host可以写全指定主机，ServerAliveInterval是多久发心跳确认连接，ServerAliveCountMax为保持连接的最大客户端数量。 123Host *ServerAliveInterval 60 ServerAliveCountMax 16","tags":[{"name":"ssh","slug":"ssh","permalink":"https://itwork.group/tags/ssh/"}]},{"title":"ubuntu安装社区版docker-ce","date":"2018-09-03T10:11:50.000Z","path":"ubuntu安装社区版docker-ce/","text":"服务器基本配置想都不用想，先更新一发 1sudo apt update 安装新版的docker，不使用自带的低版本docker-io，dock er-ce为社区版 12345678910# 添加https支持sudo apt install apt-transport-https ca-certificates curl software-properties-common#添加软件安装源curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt updateapt-cache policy docker-ce## 设置版本为stable的sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"sudo apt-get install docker-cedocker 国内环境可能下载比较慢，这样搞阿里云脚本安装 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 阿里云镜像手动安装 12345678910# step 1: 安装必要的一些系统工具sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# step 2: 安装GPG证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# Step 3: 写入软件源信息sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"# Step 4: 更新并安装 Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce 创建docker用户组，并添加当前用户来使用权限执行docker命令，显示connect: permission denied，那么创建docker用户组比较科学，直接sudo 不符合安全规范。 1234# 创建用户组sudo groupadd docker # 当前用户添加到docker用户组sudo usermod -aG docker $USER docker镜像源修改创建 /etc/docker/daemon.json文件，内容为 123&#123;&quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125; 1234# 重新加载配置文件sudo systemctl daemon-reload# 重启dockersudo systemctl restart docker","tags":[{"name":"docker","slug":"docker","permalink":"https://itwork.group/tags/docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://itwork.group/tags/ubuntu/"}]},{"title":"用hexo写博客的一些坑","date":"2018-09-03T10:00:18.000Z","path":"用hexo写博客的一些坑/","text":"hexo的分类和标签是两回事 一篇文章的Tags可以有多个，是平级的，都会在标签词云里显示,多个标签可以写成数组 1Tags: [hexo,博客] 一篇文章的分类就不能有多个平级的了，如果写成数组，就会变成多级的","tags":[{"name":"hexo","slug":"hexo","permalink":"https://itwork.group/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://itwork.group/tags/博客/"}]},{"title":"Vagrant集成开发环境的巧妙使用","date":"2018-08-10T05:56:19.000Z","path":"Vagrant集成开发环境的巧妙使用/","text":"vagrant就是一个虚拟机，里面可以部署开发环境，将本地目录挂载上去后，可以在里面写代码，跑服务。换机器开发的时候，只要携带虚拟机文件和Vagrantfile配置文件就行。想法就是这样，以后换机器开发就不用麻烦的搭建开发环境了。。。 一顿操作猛如虎，其实是个二百五。。。事实证明，在虚拟机里做开发，尤其是编译，超级慢，超级慢。。。而且是在我已经在Vagrantfile里配置了虚拟机的cpu和内存和宿主机一样，或者略低的前提下，也是非常慢的。如果用默认的内存，编译甚至会出现out of memory 的异常。。所以, vagrant做测试环境还行，做开发环境的话，实验证明还是不太适合的。。除非是很小的项目。 但是如果在windows上，因为shell命令不够完善，可以开一个vagrant虚拟机，然后用vscode的terminal去连接，这样界面就很好看了，windows上的shell界面实在看不习惯。。","tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://itwork.group/tags/vagrant/"},{"name":"windows","slug":"windows","permalink":"https://itwork.group/tags/windows/"},{"name":"shell","slug":"shell","permalink":"https://itwork.group/tags/shell/"}]},{"title":"Vagrant初体验","date":"2018-08-01T09:53:44.000Z","path":"Vagrant初体验/","text":"Vagrant初体验想要配一套集成开发环境，这样不会影响我电脑本地的其他配置，选择了Vagrant。 准备材料12提示Vagrant box: 一个打包好的操作系统，是一个后缀名为 `.box` 的文件，其实是一个压缩包，里面包含了 Vagrant 的配置信息和 VirtualBox 的虚拟机镜像文件。说白了就是个虚拟机系统文件，跟装windows虚拟机的ghost类似 VirtualBox安装包 https://www.virtualbox.org/wiki/Downloads Vagrant安装包 https://www.vagrantup.com/downloads.html Vagrant box 文件 http://www.vagrantbox.es/ ，官网下载慢点话，网上有人分享了一个https://pan.baidu.com/s/1wJCeWEyxKQLVPi1IH1IlYg ，我也是用的这个 ubuntu-server-16.04 安装 安装 VirtualBox，因为Vagrant的启动依赖于它。这是前提。如果是mac系统，可能需要到系统偏好设置-&gt;安全性与隐私里打开相关权限。不然安装失败。 这一步你已经成功安装了VirtualBox，然后进到你的开发目录下 1mkdir vagrant ###新建文件夹 把下载的box文件放到vagrant目录下，在vagrant下执行命令，添加前面下载的 box 到vagrant命令格式：vagrant box add &lt;取个本地box名称&gt; &lt;box 文件&gt; 1234## 添加vagrant box add ubuntu-server-16.04 ubuntu-server-16.04-amd64-vagrant.box##查看是否添加成功vagrant box list 初始化,这个时候会在当前目录生成配置文件Vagrantfile 1vagrant init 'ubuntu-server-16.04' 启动和连接虚拟机 1234##启动vagrant up ## 连接vagrant ssh ####常用命令 如果有多个box，指定box的操作就在对应命令后加box名字 1234567891011121314151617181920vagrant init # 初始化，生成Vagrantfilevagrant up # 启动虚拟机vagrant halt # 关闭虚拟机vagrant reload # 重启虚拟机vagrant ssh # SSH 至虚拟机vagrant suspend # 挂起虚拟机vagrant resume # 唤醒虚拟机vagrant status # 查看虚拟机运行状态vagrant destroy # 销毁当前虚拟机vagrant package --output myvagrant_image.box # 将当前虚拟机打成镜像#box管理命令vagrant box list # 查看本地box列表vagrant box add # 添加box到列表vagrant box remove # 从box列表移除 # 修改了配置需要启动或重启vagrant provisionvagrant reload --provision 使用说明虚拟机的主要配置文件是Vagrantfile，第一次init后自动生成，可以自己修改。复制开发环境给别人时只要给Vagrantfile和box文件就行。具体的Vagrantfile还得细细学习。","tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://itwork.group/tags/vagrant/"}]},{"title":"mysql开启远程访问","date":"2017-12-06T07:58:02.000Z","path":"mysql开启远程访问/","text":"首先查看3306端口是不是开启了1netstat -an|grep3306 没开启就要修改文件，打开 1sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 将里面的 bind-address = 127.0.0.1 注释掉 然后重启mysql 1/etc/init.d/mysql restart 给mysql开启外链访问权限进入mysql命令 1mysql -u root -p 输入 1grant all privileges on *.* to 'root' @'%' identified by *****(密码) 改好后刷新权限信息： 1flush privileges;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://itwork.group/tags/mysql/"}]},{"title":"新入手VPS后一般需要做的事情","date":"2017-12-06T07:57:18.000Z","path":"新入手VPS后一般需要做的事情/","text":"VPS上我一般使用ubuntu，会安装一些个人工具，科学上网，部署个人应用什么的。 修改密码命令passwd 安装PIPapt install python-pip 安装SHADOWSOCKS pip install shadowsocks 建立配置文件 vi /etc/shadowsocks.json文件里内容是个json格式的字符串 123456789101112&#123;&quot;server&quot;:&quot;xx.xx.xx.xx&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:&quot;1080&quot;,&quot;port_password&quot;:&#123;&quot;aaaa&quot;:&quot;port1_password&quot;,&quot;bbbb&quot;:&quot;port2_password&quot;&#125;,&quot;timeout&quot;:600,&quot;method&quot;:&quot;rc4-md5&quot;,&quot;fast_open&quot;:true&#125; server：vps的ip port1_password 是客户端登陆的密码，aaaa是服务器端口。可以配置多个端口的密码，例如port2_password,端口我建议不要使用默认端口，写个大几千的数字，防止一些特殊原因导致连不上。（喵喵脸） 使用配置文件开启服务端：ssserver -c /etc/shadowsocks.json -d start 其他参数可以去查看官方wiki. https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E 各种系统的客户端下载地址： https://github.com/shadowsocks/ShadowsocksX-NG/releases/ 如果PIP INSTALL 的时候报这样的错的解决方案Traceback (most recent call last): File “/usr/bin/pip”, line 9… 需要修改文件 /usr/bin/pip 将里面的 123from pip import mainif __name__ == &apos;__main__&apos;: sys.exit(main()) 改成 123from pip import __main__if __name__ == &apos;__main__&apos;: sys.exit(__main__._main()) 就可以了。 如果pip install 的时候报这样的错的解决方案Traceback (most recent call last): File “/usr/bin/pip”, line 11, in ​ sys.exit(main()) File “/usr/lib/python2.7/dist-packages/pip/init.py”, line 215, in main​ locale.setlocale(locale.LC_ALL, ‘’) File “/usr/lib/python2.7/locale.py”, line 581, in setlocale​ return _setlocale(category, locale)locale.Error: unsupported locale setting 这是地区编码的问题 输入 1export LC_ALL=C OK","tags":[{"name":"vps","slug":"vps","permalink":"https://itwork.group/tags/vps/"}]},{"title":"使用docker部署wordpress","date":"2017-12-06T06:59:33.000Z","path":"使用docker部署wordpress/","text":"之前记录了直接在服务器上部署wordpress的方法，后来发现如果用docker，就能用到docker的各种好处，果断尝试。 我的服务器还是ubuntu16.04 先安装docker1sudo apt install docker.io 文件目录准备在需要的地方创建wordpress目录，里面之后会有一些文件目录挂载到docker里，实现docker里文件的持久化 1mkdir ~/wordpress-compose &amp;&amp; cd ~/wordpress-compose 编写Dockerfile在wordpress-compose目录下 1vi Dockerfile 里面写入内容,因为需要php的依赖，否则wordpress起不来，这是一个坑，然后创建了code目录 12FROM orchardup/php5ADD . /code 编写docker-compose.yml1vi docker-compose.yml 里面的内容是两个容器的配置，注意yml文件需要严格的缩进格式。需要注意的是端口的配置和数据卷的挂载。 1234567891011121314151617181920wordpress: image: wordpress links: - mariadb:mysql environment: - WORDPRESS_DB_PASSWORD=你的密码 ports: - &quot;&lt;server public IP&gt;:80:80&quot; volumes: - ./code:/code - ./html:/var/www/htmlmariadb: image: mariadb ports: - &quot;33060:3306&quot; environment: - MYSQL_ROOT_PASSWORD=你的密码 - MYSQL_DATABASE=wordpress volumes: - ./database:/var/lib/mysql 用配置文件开始部署docker1docker-compose up -d 查看在跑的docker容器 1docker ps 这样以后如果要迁移wordpress，直接移动外面的wordpress-compose目录就行，非常方便，所有数据都在里面了。","tags":[{"name":"docker","slug":"docker","permalink":"https://itwork.group/tags/docker/"},{"name":"wordpress","slug":"wordpress","permalink":"https://itwork.group/tags/wordpress/"}]},{"title":"域名指向的apache默认首页改为wordpress网站首页","date":"2017-11-07T07:59:26.000Z","path":"域名指向的apache默认首页改为wordpress网站首页/","text":"参照之前搭建的wordpress博客，配置好域名之后，浏览器访问 http://www.itwork.group 出现的是apache的默认页面，而不是博客首页。这个时候输入 http://www.itwork.group/wordpress 才会出现博客首页。然而这不是我想要的。（当然这里我已经改好了） 目标 访问域名可以直接到达博客首页。 实现方法首先进入wordpress后台的settings,把站点地址（URL）改为域名，比如我的就是http://www.itwork.group，点保存更改。这个时候还是不能用域名访问的。还要继续配置。 因为我的wordpress是安装在 /var/www/html/wordpress 目录下的。所以进入目录/var/www/html 先备份/var/www/html目录下的index.html文件，防止出错。 cp index.hrml index_back.hrml 把wordpress目录下的index.php 复制到外面 cp /var/www/html/wordpress/index.php /var/www/html/index.php 用vi修改index.php文件里面的首页文件地址 文件最后一句 require( dirname( FILE ) . ‘/wp-blog-header.php’ ); 改为 require( dirname( FILE ) . ‘/wordpress/wp-blog-header.php’ );vi 改好了保存退出 因为php不需要重新编译，改好了就可以通过域名访问了，妥妥的。","tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://itwork.group/tags/wordpress/"},{"name":"apache","slug":"apache","permalink":"https://itwork.group/tags/apache/"}]},{"title":"使用wordpress搭建个人博客","date":"2017-11-06T07:56:20.000Z","path":"使用wordpress搭建个人博客/","text":"此文记录使用wordpress搭建个人博客的步骤 需要一台服务器。手机，电脑，vps等都可以，只要要能装上Linux。 如果是用本地电脑ssh连接服务器，那么本文的localhost 需要替换为服务器ip地址 服务器搭建LAMP环境LAMP(Linux + Apache + MySQL/MariaDB/Percona + PHP) 依次执行如下命令，安装过程中输入密码等注意看提示。如果已经处于root权限就不需要sudo 安装数据库，^符号必须有 1sudo apt install lamp-server^ 安装数据库管理工具 1sudo apt install phpmyadmin 重启数据库和阿帕齐 12sudo service mysql restartsudo service apache2 restart 浏览器登录http://localhost/phpmyadmin看是否出现初始登录界面。这里可以管理数据库。 123sudo cp -r ./wordpress /var/www/htmlcd /var/www/htmlsudo chmod -R 777 wordpress 安装WordPress到https://cn.wordpress.org/去下载最新的WordPress中文版本。然后解压到当前目录。 复制解压后的wordpress文件夹到/var/www/html目录下,进入/var/www/html 目录,给wordpress目录赋权，需要所有用户能读写的权限 123sudo cp -r ./wordpress /var/www/htmlcd /var/www/htmlsudo chmod -R 777 wordpress 登录http://localhost/wordpress/ ，出现设置界面表示以上步骤没问题。但是这时候可能进不去，因为数据库和wordpress的配置信息还没有做好。接下来马上做这个。 新建数据库和配置网站登录http://localhost/phpmyadmin，点击数据库，输入数据库名，比如wordpress，然后点击创建。也可以去建一个新用户，然后赋权，但一般还是用root用户就行了。 修改配置文件 ，依次执行如下命令，就是将默认的示例配置文件复制一个，然后修改为你的配置信息 123cd /var/www/html/wordpresscp wp-config-sample.php wp-config.phpsudo vi wp-config.php 将 wp-config.php文件里的下面配置修改 1234567891011/** WordPress数据库的名称 */define(&apos;DB_NAME&apos;, &apos;wordpress&apos;);/** MySQL数据库用户名 */define(&apos;DB_USER&apos;, &apos;root&apos;);/** MySQL数据库密码 */define(&apos;DB_PASSWORD&apos;, &apos;******&apos;);/** MySQL主机,一个机器上就是 localhost ，否则就是ip */define(&apos;DB_HOST&apos;, &apos;localhost&apos;); 改好后保存退出，浏览器 访问 http://localhost/wordpress/，注册网站管理员，妥妥的。 安装插件如果安装插件，发现需要FTP账号密码，其实可以绕过去。办法还是修改wp-config.php，在文件里添加如下代码。 123456/** 不需要ftp密码直接下载安装插件*/define(&quot;FS_METHOD&quot;,&quot;direct&quot;);define(&quot;FS_CHMOD_DIR&quot;, 0777);define(&quot;FS_CHMOD_FILE&quot;, 0777);","tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://itwork.group/tags/wordpress/"}]}]